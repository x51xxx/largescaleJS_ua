<!-- ### Мозковий штурм -->

Давайте трохи подумаємо, що ми хочемо отримати.

{:class="message"}
Ми хочемо отримати слабо пов'язану архітектура з функціональністю, розділеною
на **незалежні модулі**, які, в ідеалі, не повинні мати залежностей один
від одного. Коли трапляється щось цікаве, модулі **повідомляють** про це іншим
частинами програми, а проміжний шар інтерпретує їх повідомлення і необхідним
чином реагує на них.

Для прикладу, у нас є JavaScript-додаток, відповідальний за онлайн-пекарню. Одне з
цікавих нам повідомлення може бути таким: «Партія з 42 батонів готова до доставки».

Ми використовуємо окремий шар для обробки повідомлень модулів, щоб а) модулі
не взаємодіяли безпосередньо з ядром, б) модулі не взаємодіяли безпосередньо
один з одним. Це допомагає не допустити падіння додатка з-за різних
помилок всередині одного з модулів. Також це дозволяє нам перезапускати модулі
якщо вони раптом перестали працювати через який-небудь помилки.

Ще один момент - безпека. Насправді, мало хто з нас дбає
про внутрішню безпеку своїх додатків в належній мірі. Коли ми визначаємо
структуру програми, ми говоримо собі, що ми досить розумні для того, щоб
розуміти що в нашому коді має бути публічним, а що приватним.

Добре, але чи допоможе це якщо ви вирішите визначити що саме дозволено
модулю виконувати в системі? Приміром, у моєму додатку, обмеживши доступ з
модуля веб-чату до інтерфейсу модуля адміністрування, я зможу зменшити шанси
на успішне використання XSS уразливостей, які я не зміг знайти в віджеті.
Модулі не повинні мати доступ до всього. Ймовірно, у вашої існуючої
архітектурі вони можуть використовувати будь-які частини системи, але чи впевнені ви, що
це дійсно необхідно?

Проміжний шар, перевіряючий має модуль доступ до певної частини
вашого фреймворку, забезпечує більшу безпеку вашої системи. Фактично,
це означає, що модулі можуть взаємодіяти тільки з тими компонентами
системи, з якими ми дозволимо їм взаємодіяти.


### Архітектура, яку я пропоную вам

Архітектура, про яку ми говоримо, що представляє собою комбінацію трьох
відомих шаблонів проектування: модуль, фасад і медіатор.

На відміну від традиційної моделі, в якій модулі безпосередньо взаємодіють один з
одним, у цій слабкозв'язаній архітектурі модулі всього лише публікують події (в
ідеалі, не знаючи про інші модулі в системі). Медіатор використовується для підписки на
повідомлення від модулів і для рішення, яким повинен давати відповідь на повідомлення. Патерн
фасад використовується для обмеження дій дозволених модулів.

У наступних розділах я більш детально розповім про кожне з цих шаблонів
проектування.